# 业务都要分层

对于绝大部分软件系统而言，基本都可以分为三层架构：
1. **API层**（表现层/接口层）
2. **逻辑层**（业务层/服务层）
3. **数据层**（基础设施层）

---

## 三层架构详解

### 1. API层（表现层/接口层）

**职责：**
- 接收外部请求（HTTP/gRPC/消息队列等）
- 参数校验和转换
- 调用逻辑层处理业务
- 返回响应结果

**特点：**
- 不包含业务逻辑，只负责协议转换
- 快速失败：参数校验不通过直接返回错误
- 与协议解耦：核心业务逻辑不依赖具体的API协议

---

### 2. 逻辑层（业务层/服务层）

**职责：**
- 实现核心业务逻辑
- 编排多个数据层操作（如事务管理）
- 业务规则校验和处理
- 数据聚合和转换

**特点：**
- 不依赖具体的API协议（可以是HTTP、gRPC、消息队列触发）
- 不依赖具体的数据存储方式（通过接口抽象）
- 纯粹的领域逻辑，易于测试

---

### 3. 数据层（基础设施层）

**职责：**
- 数据持久化（数据库读写）
- 外部服务调用（RPC/HTTP调用其他服务）
- 缓存操作
- 消息队列等基础设施操作

**注意：** 根据架构类型，第三层的内容不同：

#### 单体应用架构
- 主要是**数据访问层**（DAO/Repository）
- 负责数据库操作（MySQL、Redis等）
- 可能调用外部HTTP接口

#### 微服务架构
- **数据访问层**：本服务的数据操作（数据库、缓存）
- **RPC层**：调用其他微服务
- 两者都属于"基础设施层"，负责与外部系统的交互

---

## 为什么需要分层？

### 1. **职责分离**
每层只关注自己的职责，降低复杂度。

### 2. **易于测试**
- API层：可以mock逻辑层进行测试
- 逻辑层：可以mock数据层进行单元测试，不依赖真实数据库
- 数据层：可以独立测试数据访问逻辑

### 3. **易于替换**
- 更换API协议（从HTTP改为gRPC）只需修改API层
- 更换数据库（从MySQL改为PostgreSQL）只需修改数据层
- 核心业务逻辑层不受影响

### 4. **团队协作**
- 前端/客户端团队关注API层
- 后端团队关注逻辑层和数据层
- 不同团队可以并行开发

---

## 实际例子

### 示例：用户注册功能

**API层：**
```go
// handler/user.go
func RegisterUser(c *gin.Context) {
    var req RegisterRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(400, gin.H{"error": "参数错误"})
        return
    }
    
    user, err := userService.Register(req)
    if err != nil {
        c.JSON(500, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(200, user)
}
```

**逻辑层：**
```go
// service/user.go
func (s *UserService) Register(req RegisterRequest) (*User, error) {
    // 业务规则校验
    if err := s.validateRegister(req); err != nil {
        return nil, err
    }
    
    // 检查用户是否已存在
    exists, err := s.userRepo.ExistsByEmail(req.Email)
    if err != nil {
        return nil, err
    }
    if exists {
        return nil, errors.New("用户已存在")
    }
    
    // 创建用户
    user := &User{
        Email: req.Email,
        Password: hashPassword(req.Password),
    }
    return s.userRepo.Create(user)
}
```

**数据层：**
```go
// repository/user.go
func (r *UserRepository) ExistsByEmail(email string) (bool, error) {
    var count int64
    err := r.db.Model(&User{}).Where("email = ?", email).Count(&count).Error
    return count > 0, err
}

func (r *UserRepository) Create(user *User) (*User, error) {
    err := r.db.Create(user).Error
    return user, err
}
```

---

## 分层原则

1. **单向依赖**：API层 → 逻辑层 → 数据层，不允许反向依赖
2. **接口隔离**：层与层之间通过接口交互，而不是具体实现
3. **业务下沉**：核心业务逻辑放在逻辑层，其他层尽可能薄
4. **依赖注入**：通过依赖注入让逻辑层依赖数据层的接口，便于测试和替换