# 业务都要分层

对于绝大部分软件系统而言，基本都可以分为三层架构：
1. **API层**（表现层/接口层）
2. **逻辑层**（业务层/服务层）
3. **数据层**（基础设施层）

**扩展：事件处理层**（与API层并列，处理内部事件）

---

## 三层架构详解

### 1. API层（表现层/接口层）

**职责：**
- 接收外部请求（HTTP/gRPC/消息队列等）
- 参数校验和转换
- 调用逻辑层处理业务
- 返回响应结果

**特点：**
- 不包含业务逻辑，只负责协议转换
- 快速失败：参数校验不通过直接返回错误
- 与协议解耦：核心业务逻辑不依赖具体的API协议

---

### 2. 逻辑层（业务层/服务层）

**职责：**
- 实现核心业务逻辑
- 编排多个数据层操作（如事务管理）
- 业务规则校验和处理
- 数据聚合和转换

**特点：**
- 不依赖具体的API协议（可以是HTTP、gRPC、消息队列触发）
- 不依赖具体的数据存储方式（通过接口抽象）
- 纯粹的领域逻辑，易于测试

---

### 3. 数据层（基础设施层）

**职责：**
- 数据持久化（数据库读写）
- 外部服务调用（RPC/HTTP调用其他服务）
- 缓存操作
- 消息队列等基础设施操作

**注意：** 根据架构类型，第三层的内容不同：

#### 单体应用架构
- 主要是**数据访问层**（DAO/Repository）
- 负责数据库操作（MySQL、Redis等）
- 可能调用外部HTTP接口

#### 微服务架构
- **数据访问层**：本服务的数据操作（数据库、缓存）
- **RPC层**：调用其他微服务
- 两者都属于"基础设施层"，负责与外部系统的交互

---

### 4. 事件处理层（Event Handler Layer）- 可选扩展层

**职责：**
- 接收内部事件（数据变更、领域事件等）
- 事件筛选和路由
- 分发事件到不同的业务服务
- 处理事件的副作用（发邮件、更新缓存、统计等）

**特点：**
- 与API层并列，都是逻辑层的"上游"
- 只处理内部事件，不处理外部HTTP请求
- 解耦业务逻辑，避免Service层依赖过多

**架构关系：**
```
外部请求 → API层 → 逻辑层 → 数据层
                          ↑
内部事件 → 事件处理层 ────┘
```

**什么时候需要？**
- 事件触发的业务逻辑较多（3个以上）
- 需要事件筛选、路由等复杂逻辑
- 系统规模较大，需要更好的解耦

**什么时候不需要？**
- 简单的业务处理（1-2个操作）
- 小项目，过度设计反而增加复杂度

详细说明和代码示例见下面的"回调函数/事件处理"章节。

---

## 为什么需要分层？

### 1. **职责分离**
每层只关注自己的职责，降低复杂度。

### 2. **易于测试**
- API层：可以mock逻辑层进行测试
- 逻辑层：可以mock数据层进行单元测试，不依赖真实数据库
- 数据层：可以独立测试数据访问逻辑

### 3. **易于替换**
- 更换API协议（从HTTP改为gRPC）只需修改API层
- 更换数据库（从MySQL改为PostgreSQL）只需修改数据层
- 核心业务逻辑层不受影响

### 4. **团队协作**
- 前端/客户端团队关注API层
- 后端团队关注逻辑层和数据层
- 不同团队可以并行开发

---

## 实际例子

### 示例：用户注册功能

**API层：**
```go
// handler/user.go
func RegisterUser(c *gin.Context) {
    var req RegisterRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(400, gin.H{"error": "参数错误"})
        return
    }
    
    user, err := userService.Register(req)
    if err != nil {
        c.JSON(500, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(200, user)
}
```

**逻辑层：**
```go
// service/user.go
func (s *UserService) Register(req RegisterRequest) (*User, error) {
    // 业务规则校验
    if err := s.validateRegister(req); err != nil {
        return nil, err
    }
    
    // 检查用户是否已存在
    exists, err := s.userRepo.ExistsByEmail(req.Email)
    if err != nil {
        return nil, err
    }
    if exists {
        return nil, errors.New("用户已存在")
    }
    
    // 创建用户
    user := &User{
        Email: req.Email,
        Password: hashPassword(req.Password),
    }
    return s.userRepo.Create(user)
}
```

**数据层：**
```go
// repository/user.go
func (r *UserRepository) ExistsByEmail(email string) (bool, error) {
    var count int64
    err := r.db.Model(&User{}).Where("email = ?", email).Count(&count).Error
    return count > 0, err
}

func (r *UserRepository) Create(user *User) (*User, error) {
    err := r.db.Create(user).Error
    return user, err
}
```

---

---

## 回调函数/事件处理应该放在哪一层？

这是一个很常见的问题。答案是：**取决于回调的来源和职责**。

### 场景1：数据层的数据变更回调（内部事件）

**例如：** 数据库变更监听、缓存失效回调、本地事件总线

**✅ 正确做法：回调处理逻辑放在逻辑层**

```go
// ❌ 错误：把业务逻辑放在数据层
// repository/user.go
func (r *UserRepository) Create(user *User) error {
    err := r.db.Create(user).Error
    if err == nil {
        // ❌ 业务逻辑不应该在数据层
        sendWelcomeEmail(user.Email)  // 业务逻辑！
        updateUserCache(user.ID)      // 业务逻辑！
    }
    return err
}

// ✅ 正确：数据层只负责数据操作
// repository/user.go
func (r *UserRepository) Create(user *User) error {
    return r.db.Create(user).Error
}

// ✅ 正确：业务逻辑在逻辑层，发布事件
// service/user.go
func (s *UserService) Register(req RegisterRequest) (*User, error) {
    user, err := s.userRepo.Create(req)
    if err != nil {
        return nil, err
    }
    
    // ✅ 发布领域事件，不直接处理副作用
    s.eventBus.Publish("user.created", &UserCreatedEvent{
        UserID: user.ID,
        Email:  user.Email,
        // ... 其他字段
    })
    return user, nil
}

// ⚠️ 改进方案：独立的事件处理层（推荐用于复杂场景）
// 详见下面的"事件处理层"章节
```

**原则：**
- 数据层的回调注册点应该尽可能薄，只负责触发事件或调用逻辑层的接口
- 实际的业务处理逻辑必须在逻辑层
- 如果事件处理逻辑复杂、涉及多个服务，建议使用独立的事件处理层

---

### 场景1扩展：事件处理层（Event Handler Layer）

**问题：** 当用户创建后，需要做很多事情（发邮件、更新缓存、统计、推荐等），如果都在 `UserService` 里处理，会导致：
- `UserService` 依赖太多其他服务（EmailService、CacheService、AnalyticsService等）
- 业务逻辑耦合严重，难以扩展
- 测试困难

**解决方案：** 引入**事件处理层**，与API层并列，负责接收、筛选和分发事件。

#### 架构关系

```
API层 (Handler)         事件处理层 (Event Handler)
    ↓                           ↑
逻辑层 (Service) ←──────────────┘
    ↓
数据层 (Repository)
```

#### 代码示例

**1. 逻辑层：只负责核心业务和发布事件**

```go
// service/user.go - 逻辑层
type UserService struct {
    userRepo repository.UserRepository
    eventBus eventbus.EventBus  // 事件总线
}

func (s *UserService) Register(req RegisterRequest) (*User, error) {
    // 核心业务逻辑
    user, err := s.userRepo.Create(req)
    if err != nil {
        return nil, err
    }
    
    // ✅ 发布领域事件，不处理副作用
    s.eventBus.Publish("user.created", &UserCreatedEvent{
        UserID:  user.ID,
        Email:   user.Email,
        CreatedAt: user.CreatedAt,
    })
    
    return user, nil
}
```

**2. 事件处理层：接收、筛选、分发事件**

```go
// eventhandler/user_event_handler.go - 事件处理层（与API层并列）
type UserEventHandler struct {
    emailService     service.EmailService
    cacheService     service.CacheService
    analyticsService service.AnalyticsService
    recommendService service.RecommendService
    // ... 其他服务
}

// ✅ 事件处理层的方法，与API层的Handler方法并列
func (h *UserEventHandler) OnUserCreated(ctx context.Context, event *UserCreatedEvent) error {
    // 1. 事件筛选：根据条件决定是否处理
    if h.shouldSkip(event) {
        return nil
    }
    
    // 2. 分发到不同的业务服务（并发处理，互不影响）
    var wg sync.WaitGroup
    errCh := make(chan error, 4)
    
    // 发送欢迎邮件
    wg.Add(1)
    go func() {
        defer wg.Done()
        if err := h.emailService.SendWelcomeEmail(event.Email); err != nil {
            errCh <- fmt.Errorf("send email failed: %w", err)
        }
    }()
    
    // 更新缓存
    wg.Add(1)
    go func() {
        defer wg.Done()
        if err := h.cacheService.UpdateUserCache(event.UserID); err != nil {
            errCh <- fmt.Errorf("update cache failed: %w", err)
        }
    }()
    
    // 统计分析
    wg.Add(1)
    go func() {
        defer wg.Done()
        if err := h.analyticsService.TrackUserRegistered(event.UserID); err != nil {
            errCh <- fmt.Errorf("track analytics failed: %w", err)
        }
    }()
    
    // 推荐系统
    wg.Add(1)
    go func() {
        defer wg.Done()
        if err := h.recommendService.UpdateUserRecommendations(event.UserID); err != nil {
            errCh <- fmt.Errorf("update recommendations failed: %w", err)
        }
    }()
    
    wg.Wait()
    close(errCh)
    
    // 收集错误（但不影响主流程）
    var errs []error
    for err := range errCh {
        errs = append(errs, err)
    }
    
    if len(errs) > 0 {
        return fmt.Errorf("some handlers failed: %v", errs)
    }
    
    return nil
}

func (h *UserEventHandler) shouldSkip(event *UserCreatedEvent) bool {
    // 事件筛选逻辑
    // 例如：测试账号跳过某些处理
    if strings.HasPrefix(event.Email, "test@") {
        return true
    }
    return false
}
```

**3. 应用初始化：注册事件处理器**

```go
// main.go 或初始化代码
func init() {
    // 初始化服务
    userService := service.NewUserService(userRepo, eventBus)
    emailService := service.NewEmailService()
    cacheService := service.NewCacheService()
    analyticsService := service.NewAnalyticsService()
    recommendService := service.NewRecommendService()
    
    // ✅ 初始化事件处理层（与API层并列）
    userEventHandler := eventhandler.NewUserEventHandler(
        emailService,
        cacheService,
        analyticsService,
        recommendService,
    )
    
    // ✅ 事件处理层订阅事件（在逻辑层的上游）
    eventBus.Subscribe("user.created", userEventHandler.OnUserCreated)
    
    // API层的Handler注册（与事件处理层并列）
    userHandler := handler.NewUserHandler(userService)
    router.POST("/users", userHandler.Register)
}
```

#### 事件处理层的优势

1. **解耦业务逻辑**
   - `UserService` 不需要依赖 EmailService、CacheService 等
   - 各个业务服务之间互不依赖

2. **易于扩展**
   - 新增业务处理（如短信通知）只需在事件处理层添加，不需要修改 `UserService`
   - 每个处理器可以独立开发、测试、部署

3. **事件筛选和路由**
   - 可以在事件处理层统一处理事件筛选、优先级、重试等逻辑
   - 支持事件路由到不同的处理器

4. **与API层并列**
   - API层处理外部请求 → 逻辑层
   - 事件处理层处理内部事件 → 逻辑层
   - 两者都是逻辑层的"上游"，但职责不同

#### 什么时候使用事件处理层？

**✅ 适合使用：**
- 事件触发的业务逻辑较多（3个以上）
- 业务逻辑之间相互独立，可以异步处理
- 需要支持事件的筛选、路由、重试等复杂逻辑
- 系统规模较大，需要更好的解耦

**⚠️ 简单场景可以不使用：**
- 只有1-2个简单的业务处理
- 逻辑简单，直接放在Service层即可
- 小项目，过度设计反而增加复杂度

---

### 场景2：外部系统的回调（Webhook/HTTP回调）

**例如：** 第三方支付回调、外部系统webhook

**✅ 正确做法：API层接收，逻辑层处理**

```go
// ✅ 正确：API层接收回调
// handler/payment.go
func PaymentCallback(c *gin.Context) {
    var req PaymentCallbackRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(400, gin.H{"error": "参数错误"})
        return
    }
    
    // 调用逻辑层处理
    err := paymentService.HandleCallback(req)
    if err != nil {
        c.JSON(500, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(200, gin.H{"status": "ok"})
}

// ✅ 正确：业务逻辑在逻辑层
// service/payment.go
func (s *PaymentService) HandleCallback(req PaymentCallbackRequest) error {
    // 验证回调签名
    if !s.verifySignature(req) {
        return errors.New("签名验证失败")
    }
    
    // 更新订单状态
    order, err := s.orderRepo.UpdateStatus(req.OrderID, req.Status)
    if err != nil {
        return err
    }
    
    // 业务逻辑处理
    if req.Status == "paid" {
        s.onOrderPaid(order)
    }
    
    return nil
}
```

---

### 场景3：消息队列消费者

**例如：** Kafka消费者、RabbitMQ消费者

**✅ 正确做法：作为API层的一种形式（消息API），逻辑在逻辑层**

```go
// ✅ 消息队列消费者可以作为API层的一种形式
// handler/message_consumer.go
func ConsumeOrderMessage(msg *kafka.Message) error {
    var event OrderCreatedEvent
    if err := json.Unmarshal(msg.Value, &event); err != nil {
        return err
    }
    
    // 调用逻辑层处理
    return orderService.HandleOrderCreated(event)
}

// ✅ 业务逻辑在逻辑层
// service/order.go
func (s *OrderService) HandleOrderCreated(event OrderCreatedEvent) error {
    // 业务逻辑处理
    // 通知库存系统
    // 发送通知
    // 更新统计数据
    return nil
}
```

---

### 场景4：数据层的回调注册（数据库变更监听）

**具体例子：** 如果你在数据层注册了数据库变更回调

#### 方式1：直接回调（简单场景）

```go
// repository/user.go - 数据层
type UserRepository struct {
    db *gorm.DB
    onChangeCallbacks []func(*User)  // 回调函数列表
}

func (r *UserRepository) RegisterOnChange(callback func(*User)) {
    r.onChangeCallbacks = append(r.onChangeCallbacks, callback)
}

func (r *UserRepository) Create(user *User) error {
    err := r.db.Create(user).Error
    if err == nil {
        // 触发回调
        for _, cb := range r.onChangeCallbacks {
            cb(user)
        }
    }
    return err
}

// ⚠️ 简单场景：回调处理逻辑在逻辑层
// service/user.go
func (s *UserService) OnUserCreated(user *User) {
    // 简单业务逻辑处理（1-2个操作）
    s.emailService.SendWelcomeEmail(user.Email)
    s.cacheService.UpdateUserCache(user.ID)
}
```

#### 方式2：通过事件总线 + 事件处理层（推荐，复杂场景）

**更优雅的方式：** 数据层发布事件，事件处理层处理

```go
// repository/user.go - 数据层
type UserRepository struct {
    db       *gorm.DB
    eventBus eventbus.EventBus  // 事件总线
}

func (r *UserRepository) Create(user *User) error {
    err := r.db.Create(user).Error
    if err == nil {
        // ✅ 发布事件，而不是直接回调
        r.eventBus.Publish("user.created", &UserCreatedEvent{
            UserID: user.ID,
            Email:  user.Email,
        })
    }
    return err
}

// ✅ 事件处理层处理事件（与API层并列）
// eventhandler/user_event_handler.go
func (h *UserEventHandler) OnUserCreated(ctx context.Context, event *UserCreatedEvent) error {
    // 事件筛选、分发到不同的业务服务
    // ... (见场景1扩展的代码示例)
}
```

**两种方式对比：**

| 方式 | 适用场景 | 优点 | 缺点 |
|------|---------|------|------|
| 直接回调 | 简单场景，只有1-2个处理 | 简单直接 | 耦合度高，难以扩展 |
| 事件总线+事件处理层 | 复杂场景，多个处理 | 解耦、易扩展、支持筛选路由 | 稍微复杂一些 |

**关键点：**
- ✅ 数据层只负责**触发**回调或发布事件，不包含业务逻辑
- ✅ 回调/事件处理逻辑放在**逻辑层**或**事件处理层**
- ✅ 复杂场景推荐使用**事件处理层**（与API层并列）
- ❌ 不要将业务逻辑写在数据层的回调中

---

## 总结：回调函数/事件处理的放置原则

1. **如果回调包含业务逻辑**
   - **简单场景（1-2个处理）** → 放在**逻辑层**
   - **复杂场景（3个以上处理）** → 使用**事件处理层**（与API层并列）

2. **如果回调是外部HTTP请求** → **API层**接收，调用**逻辑层**处理

3. **如果回调是消息队列** → 作为**API层**的一种形式，调用**逻辑层**处理

4. **数据层的回调注册**
   - 数据层只负责**触发**回调或发布事件
   - 回调/事件处理逻辑放在**逻辑层**或**事件处理层**

### 架构层级关系总结

```
API层 (Handler)         事件处理层 (Event Handler)
    ↓                           ↑
逻辑层 (Service) ←──────────────┘
    ↓
数据层 (Repository)
```

- **API层** 和 **事件处理层** 是并列的，都是逻辑层的"上游"
- **API层** 处理外部请求（HTTP/gRPC/消息队列）
- **事件处理层** 处理内部事件（数据变更、领域事件等）
- **逻辑层** 实现核心业务逻辑
- **数据层** 负责数据持久化和外部系统交互

**核心原则：业务逻辑永远在逻辑层或事件处理层，其他层只负责协议转换和触发。**

---

## 分层原则

1. **单向依赖**：API层 → 逻辑层 → 数据层，不允许反向依赖
2. **接口隔离**：层与层之间通过接口交互，而不是具体实现
3. **业务下沉**：核心业务逻辑放在逻辑层，其他层尽可能薄
4. **依赖注入**：通过依赖注入让逻辑层依赖数据层的接口，便于测试和替换
5. **回调处理**：回调函数如果有业务逻辑，放在逻辑层；数据层只负责触发回调