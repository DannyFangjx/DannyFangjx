
# Go代码规范与工程品味

## 参考资源
- Konrad Reiche《Writing Better Go》(GoLab 2025): https://zhuanlan.zhihu.com/p/1963878815731286081?share_code=NHey4S1Ul5YC&utm_psn=1966488239067075249
- Sean Goedecke《技术品味》: https://www.seangoedecke.com/taste/

---

## 一、Writing Better Go 要点总结

| 主题 | 核心建议 | 具体要点 / 检查清单 | 常见误区 | 工具 / 示例 |
|---|---|---|---|---|
| **项目结构** | 按职责划分，入口在 `cmd` 下 | - 应用入口放 `cmd/<app>`；库代码放 `pkg`/内部实现放 `internal`<br>- 包以"单一目的"为单位；相同功能聚合在同一父级<br>- 目录命名体现业务语义而非技术细节 | 将所有代码堆在 `main.go`；包内职责过多；循环依赖 | 参考标准布局；`go list ./...` 检查依赖 |
| **依赖与可测试性** | 包边界服务于测试 | - 对外暴露接口，内部注入实现以便替换<br>- 最小化包的公开表面积<br>- 避免"跨包耦合"导致难以 mock | 将第三方客户端直写到业务层；为测试导出多余符号 | `interface` + 构造函数注入；`internal` 限定可见性 |
| **错误处理** | 面向语义的错误并保留上下文 | - 使用 `errors.Join/Is/As` 语义化处理<br>- 用 `fmt.Errorf("...: %w", err)` 包裹上下文<br>- 仅在不可恢复时 `panic`（如必需的初始化失败） | 吞错或丢上下文；滥用 `panic`；以字符串匹配错误 | `errors` 包；统一 `logger` 打印带请求/实体标识 |
| **并发与资源** | 用消息传递和上下文治理生命周期 | - "不要通过共享内存来通信"；优先 channel 与不可变值<br>- 所有 goroutine 接收 `context.Context`，支持取消<br>- 正确关闭通道，防止泄漏；使用 `errgroup` 聚合错误 | 读写竞争；忘记取消/关闭导致泄漏；滥用无缓冲通道 | `golang.org/x/sync/errgroup`；`-race` 检测 |
| **API 设计** | 简洁、可组合、稳定 | - 函数参数少且语义明确；返回值位置一致（val, err）<br>- 选用 `Option` 模式替代长参数列<br>- 避免导出不稳定类型与字段 | 破坏调用方的向后兼容；返回零值但不说明语义 | `functional options` 模式；版本化接口 |
| **代码风格** | 统一风格、可读优先 | - 使用 `gofmt`, `goimports`, `golangci-lint`<br>- 命名清晰、避免缩写；短函数、早返回、窄作用域<br>- 零值友好类型；避免过度通用化 | 过度抽象；隐藏副作用；使用晦涩缩写 | `gofmt`, `goimports`, `golangci-lint` |
| **测试策略** | 表驱动、快速稳定 | - 使用表驱动测试覆盖边界；优先纯单元测试<br>- 隔离外部依赖：fake/mock/契约测试<br>- 基准测试辅以 `-bench` 与小型数据集 | 测试依赖网络/时间随机性；用例不可重复 | `testing`, `testdata/`, `-run`, `-bench`, `-race` |
| **性能与剖析** | 先测量再优化 | - 用 `pprof`, `trace`, `benchstat` 定位瓶颈<br>- 注意分配热点与切片/映射增长策略<br>- 避免过早优化，持久化结果对比 | 以感觉替代理论与数据；优化非瓶颈路径 | `go test -bench -benchmem`, `pprof`, `trace` |
| **观测性** | 可见性是生产力 | - 结构化日志，统一字段（trace_id, user_id 等）<br>- metrics 三要素：计数、分布、维度<br>- 关键路径埋点与采样，错误分级 | 打日志但不可检索；高基数标签爆炸 | `otel`, `prometheus`, `zap`/`zerolog` |
| **配置与环境** | 12-Factor，明确边界 | - 配置来自环境/文件且可验证；默认安全<br>- 明确超时/重试/退避策略 | 将凭据硬编码；无超时导致阻塞 | `viper`, `envconfig`；统一 `context` 超时 |
| **文档与可发现性** | 以使用者视角写文档 | - 为导出符号写注释；示例测试 `Example*`<br>- README 注明使用、限制、版本策略 | 注释与实现不一致；示例不可运行 | `godoc`, 示例测试驱动文档 |

---

## 二、技术品味 (Sean Goedecke)

### 核心观点
**技术品味不是关于"对错"，而是关于"价值观的排序"**

| 维度 | 核心观点 | 具体阐述 | Go语言示例 | 实践指导 |
|---|---|---|---|---|
| **品味 vs 能力** | 两个正交维度 | - 技术能力强 ≠ 品味好<br>- 技术能力弱 ≠ 品味差<br>- 品味决定成长上限 | 能写复杂系统 vs 知道什么是好系统 | 先培养品味，再提升能力 |
| **价值观排序** | 品味是价值观的优先级 | - 不是"对错"问题<br>- 是"价值观"排序差异<br>- 理解并承认差异 | for循环 vs map/filter | 明确自己的工程价值观 |
| **for循环 vs map/filter** | Go的设计哲学体现品味 | **for循环优势：**<br>- 性能透明度高<br>- 实现直接性<br>- 易于推理<br>- 灵活扩展 | ```go<br>for i, v := range items {<br>    // 直接、透明<br>}<br>``` | 选择符合Go哲学的方案 |
| **表达力 vs 性能** | 不同价值观的体现 | **map/filter偏好者：**<br>- 表达力优先<br>- 数学优雅<br>- 函数式思维 | ```go<br>// Go不原生支持<br>// 需要第三方库<br>``` | 理解语言设计意图 |
| **成熟工程师特征** | 承认价值观差异 | - 不因技术选择争论<br>- 理解不同背景<br>- 基于原则做决策 | 选择适合团队/项目的方案 | 建立自己的技术原则 |
| **坏品味识别** | 盲从"最佳实践" | - 不思考适用场景<br>- 照搬其他语言模式<br>- 忽视上下文 | 在Go中强制使用函数式风格 | 质疑每个"最佳实践" |
| **好品味培养** | 基于原则的决策 | - 明确工程价值观<br>- 理解语言设计哲学<br>- 考虑团队/项目上下文 | 遵循Go的简洁哲学 | 建立个人技术原则清单 |

### 工程价值观示例
- **性能透明度** > 表达力
- **实现的直接性** > 数学优雅  
- **简洁性** > 功能丰富性
- **可读性** > 代码行数少
- **团队一致性** > 个人偏好

### 培养好品味的实践路径
1. **质疑"最佳实践"** - 每个实践都有适用场景
2. **理解语言设计哲学** - 为什么Go这样设计？
3. **建立个人原则** - 在权衡中做出选择
4. **承认差异** - 不同背景产生不同价值观
5. **基于上下文决策** - 没有银弹，只有合适的选择

