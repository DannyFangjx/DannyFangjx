### 业务变量的熵增

所有的业务随着日益迭代和需求增加，里面需要用到的变量肯定越来越多。

举例来说，用户输入文本，然后我们请求大模型，返回llm结果给用户。

一开始，直接把用户的输入加上system prompt送到模型即可。 如下
```
func Chat(userId, userContent string) string,error{
    systemPe := getSystemPe()
    return QueryLLM(ctx, SystemPe, userContent)
}
```



第二天， 老板要求 需要针对不同等级用户写不同的SystemPrompt。

好说，我们直接加个判断即可。
```
func Chat(userId, userContent string) string,error{
    systemPeByUser := getSystemPe(userId)
    return QueryLLM(ctx, systemPeByUser, userContent)
}
```

第三天，老板要求，根据用户的性别，并且使用不同的llm模型
ok,继续
```
func Chat(userId, userContent string) string,error{
    systemPeByUser := getSystemPe(userId)
    llmModel := getLlmModel(userId)     // 获取用户对应的模型
    return QueryLLM(ctx, systemPeByUser, userContent, llmModel)
}
```

随着业务增多，你们团队的同学都来提交这一段代码。最后代码变成如下了。

```
func Chat(userId, userContent string) string,error{
    // 获取默认sysPe
    systemPeByUser := getSystemPe(userId)

    // 获取性别
    gender,err := getGender(userid)
    // 获取性别对应的pe
    sysPeByGender := getSystemPeByGender(userId)
    
    
    // 获取用户等级 
    ...
    // 获取用户等级对应的PE
    ...
    
    // 获取用户是否为vip
    ..
    // 获取vip用户对应的PE


    // 判定输入是否为敏感内容
    isSenstiveContent := checkSenstiveContent(userContent)
    llmModelSenstiveContent := getLLMModelBySenstiveContent(isSenstiveContent)


    // [复杂需求] 
    // 如果是男性，说的是敏感话题，则使用不同的PE，但如果是Vip则使用更贵的模型
    // 如果是女性，说的是用户等级超过5级，则使用5级以后得PE

    // 复杂需求2
    ..

    // 复杂需求3
    ...

    llmModel := getLlmModel(userId)     // 获取用户对应的模型
    return QueryLLM(ctx, #systemPeByUser, #userContent, #llmModel)
}
```
为了让最终请求llm的效果足够多样化，你们引入了非常多的变量，各种变量的组合来控制使用不同的 llm模型，systemPe, 是否带工具，带什么工具， userContent增加不同的槽位。

到最后，这个代码就变成一个屎山代码。 没人说得清这里面的逻辑了。

有一天，老板说，如果用户是中国人女人，则使用 一个特定的sysPE 并且使用特定的模型。并且返回一个表情包。

此时，你已经头大了，你已经改不动了。
老板说，你把满足这个条件的筛出来，然后设置参数进去不就好了。
你无言以对，你知道这个条件跟之前很多条件是有关联的，你已经说不清了，但凡一改动，很可能影响以前的功能。


这是一个最常见的难题。

有很多响应的解决办法，比如:
核心解决思路:

识别复杂度: 使用工具识别复杂代码
重构: 使用设计模式重构复杂代码
隔离: 通过架构设计隔离业务逻辑
工具化: 在适当的时候引入规则引擎、配置中心等工具
持续清理: 定期清理过时的 feature flag 和配置
关键原则:

单一职责原则: 每个函数/类只做一件事
开闭原则: 对扩展开放，对修改关闭
关注点分离: 将业务逻辑与技术实现分离
YAGNI (You Aren't Gonna Need It): 不要过度设计


在执行上述改造之前，最重要的是把业务预期按照表格先列举出来。
让所有使用和实现该系统的人达成共识。 因为有太多的情况会导致覆盖了，很多情况也要考虑按优先级覆盖。

梳理表格时，要关注输入变量和输出变量。

输入变量:
1. 性别
2. 等级
3. 是否会员
4. ...


输出变量：
1. 使用什么systemPE
2. 使用什么模型
3. 带什么userContent的槽位信息。
4. ....


所以，正确的流程是

1. 梳理流程，将需求/优先级/预期 等列举到表格里。
2. 各种限制条件对应的输出预期是什么。
3. 管理所有的输入变量。
4. 合理的封装，通过输入变量拿到输出变量，然后做最后的请求。


比如最终的输入变量信息可以维护到一个session里面
```

// ChatSession 聊天会话信息，包含各个环节的输出结果
type ChatSession struct {
	// 1. 高质量内容。 用户输入命中ai高质量内容
	AITopContentOutput *AITopContentOutput
	// 2. 用户热点关键词。 用户输入命中热点关键词
	AIPresetKeywordsOutput *AIPresetKeywordsOutput
	// 3. 人设剧情RAG
	CommonRAGOutput *CommonRAGOutput
	// 4. 记忆RAG
	MemoryRAGOutput *MemoryRAGOutput
	// 5. 热点话题. 用户聊天话题不足，ai补充热点话题
	ChatStatusOutput *ChatStatusOutput
	// 6. 深刻性话题。 用户聊深刻话题
	DeepTopicOutput *JudgeDeepTopicOutput
	// 7. 判断是否是调情
	JudgeFlirtOutput *JudgeFlirtOutput

	// ChatSubCode输出
	ChatSubCodeResult structs.ChatSubCode // 7选一的输出结果。

	// 聊天模式判断.
	ChatModeOutput *ChatModeOutput

	// 意图判断
	ChatIntentionOutput *ChatIntentionOutput

	// 工具调用意图判断
	ToolUseIntentionOutput *ToolUseIntentionOutput

	// 判断输出类型。0-普通，1-输出语音条  >=2 输出表情包并且直接结束.
	ReplyTypeOutput *AIReplyTypeJudgeOutput

	// 判断回复时机。0-正常回复  1-等待用户输入  2-对话结束。
	ReplyTimingOutput *AIReplyTimingJudgeOutput

	// 链路中途-发送表情包的输出结果。
	ReplyEmojiOnlyOutput *SendEmojiByAIContentOutput

	// 文本回复后，再回复的表情包
	AfterProcessSendEmojiResult *SendEmojiOutPut
}
```

比如与上述结构对应的表格文档如下:

